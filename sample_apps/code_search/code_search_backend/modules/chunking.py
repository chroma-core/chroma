from dataclasses import dataclass
from flask import url_for
from tree_sitter import Language, Parser, Tree, Node
from tree_sitter_language_pack import SupportedLanguage, get_parser


@dataclass
class CodeContext:
    language: SupportedLanguage
    file_path: str


@dataclass
class CodeChunk:
    file_path: str
    language: str
    start_line: int

    """
    source_code is the actual code chunk ie when you do a search, this is the
    result that shows up.
    """
    source_code: str
    """
    name is the short label given to the code chunk. This could be the function
    name, class name, file name, etc.
    """
    name: str
    """
    index_document is the document that will be embedded. This is not necessarily
    the same as source_code. For example, in chunk_code_with_expanded_context
    this includes additional surrounding code, and in label_code_chunks_with_llm,
    this will be the natural language description of the code chunk generated by
    an LLM.
    """
    index_document: str | None = None


def dont_chunk(code: str, context: CodeContext) -> list[CodeChunk]:
    chunk = CodeChunk(
        source_code=code,
        file_path=context.file_path,
        name=context.file_path,
        language=context.language,
        start_line=0,
    )
    return [chunk]


def chunk_code_using_tree_sitter(code: str, context: CodeContext) -> list[CodeChunk]:
    """
    Extracts functions and methods from the code.
    """
    parser = get_parser(context.language)
    tree: Tree = parser.parse(bytes(code, "utf-8"))
    output: list[CodeChunk] = []

    def bytes_to_str(bytes: bytes | None) -> str:
        return bytes.decode("utf-8") if bytes else ""

    def get_name(node: Node) -> str:
        named_child = node.named_child(0)
        if named_child:
            return bytes_to_str(named_child.text)
        else:
            return bytes_to_str(node.text)

    allowed_node_types = ["function_definition", "method_definition", "function_item"]

    def traverse_tree(node: Node):
        for child in node.children:
            if child.type in allowed_node_types:
                chunk = CodeChunk(
                    source_code=bytes_to_str(child.text),
                    file_path=context.file_path,
                    name=get_name(child),
                    language=context.language,
                    start_line=child.start_point.row,
                )
                output.append(chunk)
            else:
                traverse_tree(child)

    traverse_tree(tree.root_node)
    return output


def chunk_code_with_expanded_context(
    code: str, context: CodeContext
) -> list[CodeChunk]:
    """
    Extracts functions and methods from the code, but it will also include
    surrounding context such as its class definition and file imports.
    """
    return []


def label_code_chunks_with_llm(chunks: list[CodeChunk]) -> list[CodeChunk]:
    return []


def truncate_documents(
    chunks: list[CodeChunk], max_length: int = 2048
) -> list[CodeChunk]:
    for chunk in chunks:
        if chunk.index_document:
            chunk.index_document = chunk.index_document[:max_length]
        if chunk.source_code:
            chunk.source_code = chunk.source_code[:max_length]
    return chunks


if __name__ == "__main__":
    raise Exception("chunking.py is not meant to be run directly.")
