/* eslint-disable */
// tslint:disable
/**
 * Chroma
 *
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError, defaultFetch } from "./runtime";
import { Api } from "./models";

export type FactoryFunction<T> = (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) => T;

/**
 * ApiApi - fetch parameter creator
 * @export
 */
export const ApiApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * @summary Add V1
     * @param {string} collectionId
     * @param {Api.AddV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    addV1V1(collectionId: string, request: Api.AddV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling addV1V1.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling addV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_id}/add`
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Add
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.AddV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    addV2(tenant: string, databaseName: string, collectionId: string, request: Api.AddV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling addV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling addV2.');
      }
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling addV2.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling addV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/add`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Count Collections V1
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCollectionsV1V1(tenant: string | undefined, database: string | undefined, options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v1/count_collections`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      if (tenant !== undefined) {
        localVarQueryParameter.append('tenant', String(tenant));
      }

      if (database !== undefined) {
        localVarQueryParameter.append('database', String(database));
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Count Collections
     * @param {string} tenant
     * @param {string} databaseName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCollectionsV2(tenant: string, databaseName: string, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling countCollectionsV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling countCollectionsV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections_count`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Count V1
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countV1V1(collectionId: string, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling countV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_id}/count`
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Count
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countV2(tenant: string, databaseName: string, collectionId: string, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling countV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling countV2.');
      }
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling countV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/count`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Create Collection V1
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {Api.CreateCollectionV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollectionV1V1(tenant: string | undefined, database: string | undefined, request: Api.CreateCollectionV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling createCollectionV1V1.');
      }
      let localVarPath = `/api/v1/collections`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      if (tenant !== undefined) {
        localVarQueryParameter.append('tenant', String(tenant));
      }

      if (database !== undefined) {
        localVarQueryParameter.append('database', String(database));
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Create Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.CreateCollectionV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollectionV2(tenant: string, databaseName: string, request: Api.CreateCollectionV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling createCollectionV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling createCollectionV2.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling createCollectionV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Create Database V1
     * @param {string} [tenant]
     * @param {Api.CreateDatabaseV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDatabaseV1V1(tenant: string | undefined, request: Api.CreateDatabaseV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling createDatabaseV1V1.');
      }
      let localVarPath = `/api/v1/databases`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      if (tenant !== undefined) {
        localVarQueryParameter.append('tenant', String(tenant));
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Create Database
     * @param {string} tenant
     * @param {Api.CreateDatabaseV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDatabaseV2(tenant: string, request: Api.CreateDatabaseV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling createDatabaseV2.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling createDatabaseV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases`
        .replace('{tenant}', encodeURIComponent(String(tenant)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Create Tenant V1
     * @param {Api.CreateTenantV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenantV1V1(request: Api.CreateTenantV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling createTenantV1V1.');
      }
      let localVarPath = `/api/v1/tenants`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Create Tenant
     * @param {Api.CreateTenantV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenantV2(request: Api.CreateTenantV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling createTenantV2.');
      }
      let localVarPath = `/api/v2/tenants`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Delete Collection V1
     * @param {string} collectionName
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollectionV1V1(collectionName: string, tenant: string | undefined, database: string | undefined, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionName' is not null or undefined
      if (collectionName === null || collectionName === undefined) {
        throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling deleteCollectionV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_name}`
        .replace('{collection_name}', encodeURIComponent(String(collectionName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      if (tenant !== undefined) {
        localVarQueryParameter.append('tenant', String(tenant));
      }

      if (database !== undefined) {
        localVarQueryParameter.append('database', String(database));
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Delete Collection
     * @param {string} collectionName
     * @param {string} tenant
     * @param {string} databaseName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollectionV2(collectionName: string, tenant: string, databaseName: string, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionName' is not null or undefined
      if (collectionName === null || collectionName === undefined) {
        throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling deleteCollectionV2.');
      }
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling deleteCollectionV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling deleteCollectionV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_name}`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_name}', encodeURIComponent(String(collectionName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Delete Database
     * @param {string} databaseName
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDatabaseV2(databaseName: string, tenant: string, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling deleteDatabaseV2.');
      }
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling deleteDatabaseV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Delete V1
     * @param {string} collectionId
     * @param {Api.DeleteV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteV1V1(collectionId: string, request: Api.DeleteV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling deleteV1V1.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling deleteV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_id}/delete`
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Delete
     * @param {string} collectionId
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.DeleteV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteV2(collectionId: string, tenant: string, databaseName: string, request: Api.DeleteV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling deleteV2.');
      }
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling deleteV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling deleteV2.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling deleteV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/delete`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get Collection V1
     * @param {string} collectionName
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionV1V1(collectionName: string, tenant: string | undefined, database: string | undefined, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionName' is not null or undefined
      if (collectionName === null || collectionName === undefined) {
        throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling getCollectionV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_name}`
        .replace('{collection_name}', encodeURIComponent(String(collectionName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      if (tenant !== undefined) {
        localVarQueryParameter.append('tenant', String(tenant));
      }

      if (database !== undefined) {
        localVarQueryParameter.append('database', String(database));
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionV2(tenant: string, databaseName: string, collectionName: string, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling getCollectionV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling getCollectionV2.');
      }
      // verify required parameter 'collectionName' is not null or undefined
      if (collectionName === null || collectionName === undefined) {
        throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling getCollectionV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_name}`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_name}', encodeURIComponent(String(collectionName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get Database V1
     * @param {string} database
     * @param {string} [tenant]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDatabaseV1V1(database: string, tenant: string | undefined, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'database' is not null or undefined
      if (database === null || database === undefined) {
        throw new RequiredError('database', 'Required parameter database was null or undefined when calling getDatabaseV1V1.');
      }
      let localVarPath = `/api/v1/databases/{database}`
        .replace('{database}', encodeURIComponent(String(database)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      if (tenant !== undefined) {
        localVarQueryParameter.append('tenant', String(tenant));
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get Database
     * @param {string} databaseName
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDatabaseV2(databaseName: string, tenant: string, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling getDatabaseV2.');
      }
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling getDatabaseV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get Nearest Neighbors V1
     * @param {string} collectionId
     * @param {Api.GetNearestNeighborsV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighborsV1V1(collectionId: string, request: Api.GetNearestNeighborsV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling getNearestNeighborsV1V1.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling getNearestNeighborsV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_id}/query`
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get Nearest Neighbors
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.GetNearestNeighborsV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighborsV2(tenant: string, databaseName: string, collectionId: string, request: Api.GetNearestNeighborsV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling getNearestNeighborsV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling getNearestNeighborsV2.');
      }
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling getNearestNeighborsV2.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling getNearestNeighborsV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/query`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get Tenant V1
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenantV1V1(tenant: string, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling getTenantV1V1.');
      }
      let localVarPath = `/api/v1/tenants/{tenant}`
        .replace('{tenant}', encodeURIComponent(String(tenant)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get Tenant
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenantV2(tenant: string, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling getTenantV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}`
        .replace('{tenant}', encodeURIComponent(String(tenant)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get User Identity
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityV2(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v2/auth/identity`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get V1
     * @param {string} collectionId
     * @param {Api.GetV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV1V1(collectionId: string, request: Api.GetV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling getV1V1.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling getV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_id}/get`
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Get
     * @param {string} collectionId
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.GetV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2(collectionId: string, tenant: string, databaseName: string, request: Api.GetV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling getV2.');
      }
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling getV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling getV2.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling getV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/get`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeatV1(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v1/heartbeat`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeatV2(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v2/heartbeat`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary List Collections V1
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionsV1V1(limit: number | null | undefined, offset: number | null | undefined, tenant: string | undefined, database: string | undefined, options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v1/collections`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      if (limit !== undefined) {
        localVarQueryParameter.append('limit', String(limit));
      }

      if (offset !== undefined) {
        localVarQueryParameter.append('offset', String(offset));
      }

      if (tenant !== undefined) {
        localVarQueryParameter.append('tenant', String(tenant));
      }

      if (database !== undefined) {
        localVarQueryParameter.append('database', String(database));
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary List Collections
     * @param {string} tenant
     * @param {string} databaseName
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionsV2(tenant: string, databaseName: string, limit: number | null | undefined, offset: number | null | undefined, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling listCollectionsV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling listCollectionsV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      if (limit !== undefined) {
        localVarQueryParameter.append('limit', String(limit));
      }

      if (offset !== undefined) {
        localVarQueryParameter.append('offset', String(offset));
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary List Databases
     * @param {string} tenant
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDatabasesV2(tenant: string, limit: number | null | undefined, offset: number | null | undefined, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling listDatabasesV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases`
        .replace('{tenant}', encodeURIComponent(String(tenant)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      if (limit !== undefined) {
        localVarQueryParameter.append('limit', String(limit));
      }

      if (offset !== undefined) {
        localVarQueryParameter.append('offset', String(offset));
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Pre Flight Checks
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    preFlightChecksV1(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v1/pre-flight-checks`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Pre Flight Checks
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    preFlightChecksV2(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v2/pre-flight-checks`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetV1(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v1/reset`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetV2(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v2/reset`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootV1(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v1`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootV2(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v2`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Update Collection V1
     * @param {string} collectionId
     * @param {Api.UpdateCollectionV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollectionV1V1(collectionId: string, request: Api.UpdateCollectionV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling updateCollectionV1V1.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateCollectionV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_id}`
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Update Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpdateCollectionV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollectionV2(tenant: string, databaseName: string, collectionId: string, request: Api.UpdateCollectionV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling updateCollectionV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling updateCollectionV2.');
      }
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling updateCollectionV2.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateCollectionV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Update V1
     * @param {string} collectionId
     * @param {Api.UpdateV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateV1V1(collectionId: string, request: Api.UpdateV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling updateV1V1.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_id}/update`
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Update
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpdateV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateV2(tenant: string, databaseName: string, collectionId: string, request: Api.UpdateV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling updateV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling updateV2.');
      }
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling updateV2.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/update`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Upsert V1
     * @param {string} collectionId
     * @param {Api.UpsertV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertV1V1(collectionId: string, request: Api.UpsertV1V1Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling upsertV1V1.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling upsertV1V1.');
      }
      let localVarPath = `/api/v1/collections/{collection_id}/upsert`
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Upsert
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpsertV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertV2(tenant: string, databaseName: string, collectionId: string, request: Api.UpsertV2Request, options: RequestInit = {}): FetchArgs {
      // verify required parameter 'tenant' is not null or undefined
      if (tenant === null || tenant === undefined) {
        throw new RequiredError('tenant', 'Required parameter tenant was null or undefined when calling upsertV2.');
      }
      // verify required parameter 'databaseName' is not null or undefined
      if (databaseName === null || databaseName === undefined) {
        throw new RequiredError('databaseName', 'Required parameter databaseName was null or undefined when calling upsertV2.');
      }
      // verify required parameter 'collectionId' is not null or undefined
      if (collectionId === null || collectionId === undefined) {
        throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling upsertV2.');
      }
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError('request', 'Required parameter request was null or undefined when calling upsertV2.');
      }
      let localVarPath = `/api/v2/tenants/{tenant}/databases/{database_name}/collections/{collection_id}/upsert`
        .replace('{tenant}', encodeURIComponent(String(tenant)))
        .replace('{database_name}', encodeURIComponent(String(databaseName)))
        .replace('{collection_id}', encodeURIComponent(String(collectionId)));
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarHeaderParameter.set('Content-Type', 'application/json');

      localVarRequestOptions.headers = localVarHeaderParameter;

      if (request !== undefined) {
        localVarRequestOptions.body = JSON.stringify(request || {});
      }

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    versionV1(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v1/version`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    versionV2(options: RequestInit = {}): FetchArgs {
      let localVarPath = `/api/v2/version`;
      const localVarPathQueryStart = localVarPath.indexOf("?");
      const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
      const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
      if (localVarPathQueryStart !== -1) {
        localVarPath = localVarPath.substring(0, localVarPathQueryStart);
      }

      localVarRequestOptions.headers = localVarHeaderParameter;

      const localVarQueryParameterString = localVarQueryParameter.toString();
      if (localVarQueryParameterString) {
        localVarPath += "?" + localVarQueryParameterString;
      }
      return {
        url: localVarPath,
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function (configuration?: Configuration) {
  return {
    /**
     * @summary Add V1
     * @param {string} collectionId
     * @param {Api.AddV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    addV1V1(collectionId: string, request: Api.AddV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).addV1V1(collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 201) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Add
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.AddV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    addV2(tenant: string, databaseName: string, collectionId: string, request: Api.AddV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).addV2(tenant, databaseName, collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 201) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Count Collections V1
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCollectionsV1V1(tenant: string | undefined, database: string | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).countCollectionsV1V1(tenant, database, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Count Collections
     * @param {string} tenant
     * @param {string} databaseName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCollectionsV2(tenant: string, databaseName: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).countCollectionsV2(tenant, databaseName, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Count V1
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countV1V1(collectionId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).countV1V1(collectionId, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Count
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countV2(tenant: string, databaseName: string, collectionId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).countV2(tenant, databaseName, collectionId, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Collection V1
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {Api.CreateCollectionV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollectionV1V1(tenant: string | undefined, database: string | undefined, request: Api.CreateCollectionV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createCollectionV1V1(tenant, database, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.CreateCollectionV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollectionV2(tenant: string, databaseName: string, request: Api.CreateCollectionV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createCollectionV2(tenant, databaseName, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Database V1
     * @param {string} [tenant]
     * @param {Api.CreateDatabaseV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDatabaseV1V1(tenant: string | undefined, request: Api.CreateDatabaseV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createDatabaseV1V1(tenant, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Database
     * @param {string} tenant
     * @param {Api.CreateDatabaseV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDatabaseV2(tenant: string, request: Api.CreateDatabaseV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createDatabaseV2(tenant, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Tenant V1
     * @param {Api.CreateTenantV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenantV1V1(request: Api.CreateTenantV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createTenantV1V1(request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Create Tenant
     * @param {Api.CreateTenantV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenantV2(request: Api.CreateTenantV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createTenantV2(request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Delete Collection V1
     * @param {string} collectionName
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollectionV1V1(collectionName: string, tenant: string | undefined, database: string | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteCollectionV1V1(collectionName, tenant, database, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Delete Collection
     * @param {string} collectionName
     * @param {string} tenant
     * @param {string} databaseName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollectionV2(collectionName: string, tenant: string, databaseName: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteCollectionV2(collectionName, tenant, databaseName, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Delete Database
     * @param {string} databaseName
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDatabaseV2(databaseName: string, tenant: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteDatabaseV2(databaseName, tenant, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Delete V1
     * @param {string} collectionId
     * @param {Api.DeleteV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteV1V1(collectionId: string, request: Api.DeleteV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteV1V1(collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Delete
     * @param {string} collectionId
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.DeleteV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteV2(collectionId: string, tenant: string, databaseName: string, request: Api.DeleteV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteV2(collectionId, tenant, databaseName, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Collection V1
     * @param {string} collectionName
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionV1V1(collectionName: string, tenant: string | undefined, database: string | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getCollectionV1V1(collectionName, tenant, database, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionV2(tenant: string, databaseName: string, collectionName: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getCollectionV2(tenant, databaseName, collectionName, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Database V1
     * @param {string} database
     * @param {string} [tenant]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDatabaseV1V1(database: string, tenant: string | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getDatabaseV1V1(database, tenant, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Database
     * @param {string} databaseName
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDatabaseV2(databaseName: string, tenant: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getDatabaseV2(databaseName, tenant, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Nearest Neighbors V1
     * @param {string} collectionId
     * @param {Api.GetNearestNeighborsV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighborsV1V1(collectionId: string, request: Api.GetNearestNeighborsV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getNearestNeighborsV1V1(collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Nearest Neighbors
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.GetNearestNeighborsV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighborsV2(tenant: string, databaseName: string, collectionId: string, request: Api.GetNearestNeighborsV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getNearestNeighborsV2(tenant, databaseName, collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Tenant V1
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenantV1V1(tenant: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getTenantV1V1(tenant, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get Tenant
     * @param {string} tenant
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenantV2(tenant: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getTenantV2(tenant, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get User Identity
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityV2(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getUserIdentityV2(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get V1
     * @param {string} collectionId
     * @param {Api.GetV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV1V1(collectionId: string, request: Api.GetV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV1V1(collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Get
     * @param {string} collectionId
     * @param {string} tenant
     * @param {string} databaseName
     * @param {Api.GetV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getV2(collectionId: string, tenant: string, databaseName: string, request: Api.GetV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getV2(collectionId, tenant, databaseName, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeatV1(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<{ [name: string]: number }> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).heartbeatV1(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeatV2(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<{ [name: string]: number }> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).heartbeatV2(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary List Collections V1
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {string} [tenant]
     * @param {string} [database]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionsV1V1(limit: number | null | undefined, offset: number | null | undefined, tenant: string | undefined, database: string | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).listCollectionsV1V1(limit, offset, tenant, database, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary List Collections
     * @param {string} tenant
     * @param {string} databaseName
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionsV2(tenant: string, databaseName: string, limit: number | null | undefined, offset: number | null | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).listCollectionsV2(tenant, databaseName, limit, offset, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary List Databases
     * @param {string} tenant
     * @param {number | null} [limit]
     * @param {number | null} [offset]
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDatabasesV2(tenant: string, limit: number | null | undefined, offset: number | null | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).listDatabasesV2(tenant, limit, offset, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Pre Flight Checks
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    preFlightChecksV1(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.PreFlightChecksV1200Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).preFlightChecksV1(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Pre Flight Checks
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    preFlightChecksV2(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.PreFlightChecksV2200Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).preFlightChecksV2(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetV1(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).resetV1(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetV2(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).resetV2(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootV1(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<{ [name: string]: number }> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).rootV1(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootV2(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<{ [name: string]: number }> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).rootV2(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Update Collection V1
     * @param {string} collectionId
     * @param {Api.UpdateCollectionV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollectionV1V1(collectionId: string, request: Api.UpdateCollectionV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).updateCollectionV1V1(collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Update Collection
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpdateCollectionV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollectionV2(tenant: string, databaseName: string, collectionId: string, request: Api.UpdateCollectionV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).updateCollectionV2(tenant, databaseName, collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Update V1
     * @param {string} collectionId
     * @param {Api.UpdateV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateV1V1(collectionId: string, request: Api.UpdateV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).updateV1V1(collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Update
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpdateV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateV2(tenant: string, databaseName: string, collectionId: string, request: Api.UpdateV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).updateV2(tenant, databaseName, collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Upsert V1
     * @param {string} collectionId
     * @param {Api.UpsertV1V1Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertV1V1(collectionId: string, request: Api.UpsertV1V1Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).upsertV1V1(collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Upsert
     * @param {string} tenant
     * @param {string} databaseName
     * @param {string} collectionId
     * @param {Api.UpsertV2Request} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertV2(tenant: string, databaseName: string, collectionId: string, request: Api.UpsertV2Request, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<unknown> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).upsertV2(tenant, databaseName, collectionId, request, options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          if (response.status === 422) {
            if (mimeType === 'application/json') {
              throw response;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    versionV1(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).versionV1(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    versionV2(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).versionV2(options);
      return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          const contentType = response.headers.get('Content-Type');
          const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;

          if (response.status === 200) {
            if (mimeType === 'application/json') {
              return response.json() as any;
            }
            throw response;
          }
          throw response;
        });
      };
    },
  }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory: FactoryFunction<ApiApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
  return new ApiApi(configuration, basePath, fetch);
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
  /**
   * @summary Add V1
   * @param {string} collectionId
   * @param {Api.AddV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public addV1V1(collectionId: string, request: Api.AddV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).addV1V1(collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Add
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.AddV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public addV2(tenant: string, databaseName: string, collectionId: string, request: Api.AddV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).addV2(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Count Collections V1
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countCollectionsV1V1(tenant: string | undefined, database: string | undefined, options?: RequestInit) {
    return ApiApiFp(this.configuration).countCollectionsV1V1(tenant, database, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Count Collections
   * @param {string} tenant
   * @param {string} databaseName
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countCollectionsV2(tenant: string, databaseName: string, options?: RequestInit) {
    return ApiApiFp(this.configuration).countCollectionsV2(tenant, databaseName, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Count V1
   * @param {string} collectionId
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countV1V1(collectionId: string, options?: RequestInit) {
    return ApiApiFp(this.configuration).countV1V1(collectionId, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Count
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countV2(tenant: string, databaseName: string, collectionId: string, options?: RequestInit) {
    return ApiApiFp(this.configuration).countV2(tenant, databaseName, collectionId, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Create Collection V1
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {Api.CreateCollectionV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createCollectionV1V1(tenant: string | undefined, database: string | undefined, request: Api.CreateCollectionV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).createCollectionV1V1(tenant, database, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Create Collection
   * @param {string} tenant
   * @param {string} databaseName
   * @param {Api.CreateCollectionV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createCollectionV2(tenant: string, databaseName: string, request: Api.CreateCollectionV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).createCollectionV2(tenant, databaseName, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Create Database V1
   * @param {string} [tenant]
   * @param {Api.CreateDatabaseV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createDatabaseV1V1(tenant: string | undefined, request: Api.CreateDatabaseV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).createDatabaseV1V1(tenant, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Create Database
   * @param {string} tenant
   * @param {Api.CreateDatabaseV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createDatabaseV2(tenant: string, request: Api.CreateDatabaseV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).createDatabaseV2(tenant, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Create Tenant V1
   * @param {Api.CreateTenantV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createTenantV1V1(request: Api.CreateTenantV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).createTenantV1V1(request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Create Tenant
   * @param {Api.CreateTenantV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createTenantV2(request: Api.CreateTenantV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).createTenantV2(request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Delete Collection V1
   * @param {string} collectionName
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteCollectionV1V1(collectionName: string, tenant: string | undefined, database: string | undefined, options?: RequestInit) {
    return ApiApiFp(this.configuration).deleteCollectionV1V1(collectionName, tenant, database, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Delete Collection
   * @param {string} collectionName
   * @param {string} tenant
   * @param {string} databaseName
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteCollectionV2(collectionName: string, tenant: string, databaseName: string, options?: RequestInit) {
    return ApiApiFp(this.configuration).deleteCollectionV2(collectionName, tenant, databaseName, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Delete Database
   * @param {string} databaseName
   * @param {string} tenant
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteDatabaseV2(databaseName: string, tenant: string, options?: RequestInit) {
    return ApiApiFp(this.configuration).deleteDatabaseV2(databaseName, tenant, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Delete V1
   * @param {string} collectionId
   * @param {Api.DeleteV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteV1V1(collectionId: string, request: Api.DeleteV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).deleteV1V1(collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Delete
   * @param {string} collectionId
   * @param {string} tenant
   * @param {string} databaseName
   * @param {Api.DeleteV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteV2(collectionId: string, tenant: string, databaseName: string, request: Api.DeleteV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).deleteV2(collectionId, tenant, databaseName, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get Collection V1
   * @param {string} collectionName
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getCollectionV1V1(collectionName: string, tenant: string | undefined, database: string | undefined, options?: RequestInit) {
    return ApiApiFp(this.configuration).getCollectionV1V1(collectionName, tenant, database, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get Collection
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionName
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getCollectionV2(tenant: string, databaseName: string, collectionName: string, options?: RequestInit) {
    return ApiApiFp(this.configuration).getCollectionV2(tenant, databaseName, collectionName, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get Database V1
   * @param {string} database
   * @param {string} [tenant]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getDatabaseV1V1(database: string, tenant: string | undefined, options?: RequestInit) {
    return ApiApiFp(this.configuration).getDatabaseV1V1(database, tenant, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get Database
   * @param {string} databaseName
   * @param {string} tenant
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getDatabaseV2(databaseName: string, tenant: string, options?: RequestInit) {
    return ApiApiFp(this.configuration).getDatabaseV2(databaseName, tenant, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get Nearest Neighbors V1
   * @param {string} collectionId
   * @param {Api.GetNearestNeighborsV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getNearestNeighborsV1V1(collectionId: string, request: Api.GetNearestNeighborsV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).getNearestNeighborsV1V1(collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get Nearest Neighbors
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.GetNearestNeighborsV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getNearestNeighborsV2(tenant: string, databaseName: string, collectionId: string, request: Api.GetNearestNeighborsV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).getNearestNeighborsV2(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get Tenant V1
   * @param {string} tenant
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getTenantV1V1(tenant: string, options?: RequestInit) {
    return ApiApiFp(this.configuration).getTenantV1V1(tenant, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get Tenant
   * @param {string} tenant
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getTenantV2(tenant: string, options?: RequestInit) {
    return ApiApiFp(this.configuration).getTenantV2(tenant, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get User Identity
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getUserIdentityV2(options?: RequestInit) {
    return ApiApiFp(this.configuration).getUserIdentityV2(options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get V1
   * @param {string} collectionId
   * @param {Api.GetV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getV1V1(collectionId: string, request: Api.GetV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).getV1V1(collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Get
   * @param {string} collectionId
   * @param {string} tenant
   * @param {string} databaseName
   * @param {Api.GetV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getV2(collectionId: string, tenant: string, databaseName: string, request: Api.GetV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).getV2(collectionId, tenant, databaseName, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Heartbeat
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public heartbeatV1(options?: RequestInit) {
    return ApiApiFp(this.configuration).heartbeatV1(options)(this.fetch, this.basePath);
  }

  /**
   * @summary Heartbeat
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public heartbeatV2(options?: RequestInit) {
    return ApiApiFp(this.configuration).heartbeatV2(options)(this.fetch, this.basePath);
  }

  /**
   * @summary List Collections V1
   * @param {number | null} [limit]
   * @param {number | null} [offset]
   * @param {string} [tenant]
   * @param {string} [database]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listCollectionsV1V1(limit: number | null | undefined, offset: number | null | undefined, tenant: string | undefined, database: string | undefined, options?: RequestInit) {
    return ApiApiFp(this.configuration).listCollectionsV1V1(limit, offset, tenant, database, options)(this.fetch, this.basePath);
  }

  /**
   * @summary List Collections
   * @param {string} tenant
   * @param {string} databaseName
   * @param {number | null} [limit]
   * @param {number | null} [offset]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listCollectionsV2(tenant: string, databaseName: string, limit: number | null | undefined, offset: number | null | undefined, options?: RequestInit) {
    return ApiApiFp(this.configuration).listCollectionsV2(tenant, databaseName, limit, offset, options)(this.fetch, this.basePath);
  }

  /**
   * @summary List Databases
   * @param {string} tenant
   * @param {number | null} [limit]
   * @param {number | null} [offset]
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listDatabasesV2(tenant: string, limit: number | null | undefined, offset: number | null | undefined, options?: RequestInit) {
    return ApiApiFp(this.configuration).listDatabasesV2(tenant, limit, offset, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Pre Flight Checks
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public preFlightChecksV1(options?: RequestInit) {
    return ApiApiFp(this.configuration).preFlightChecksV1(options)(this.fetch, this.basePath);
  }

  /**
   * @summary Pre Flight Checks
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public preFlightChecksV2(options?: RequestInit) {
    return ApiApiFp(this.configuration).preFlightChecksV2(options)(this.fetch, this.basePath);
  }

  /**
   * @summary Reset
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public resetV1(options?: RequestInit) {
    return ApiApiFp(this.configuration).resetV1(options)(this.fetch, this.basePath);
  }

  /**
   * @summary Reset
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public resetV2(options?: RequestInit) {
    return ApiApiFp(this.configuration).resetV2(options)(this.fetch, this.basePath);
  }

  /**
   * @summary Root
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rootV1(options?: RequestInit) {
    return ApiApiFp(this.configuration).rootV1(options)(this.fetch, this.basePath);
  }

  /**
   * @summary Root
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rootV2(options?: RequestInit) {
    return ApiApiFp(this.configuration).rootV2(options)(this.fetch, this.basePath);
  }

  /**
   * @summary Update Collection V1
   * @param {string} collectionId
   * @param {Api.UpdateCollectionV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public updateCollectionV1V1(collectionId: string, request: Api.UpdateCollectionV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).updateCollectionV1V1(collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Update Collection
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.UpdateCollectionV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public updateCollectionV2(tenant: string, databaseName: string, collectionId: string, request: Api.UpdateCollectionV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).updateCollectionV2(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Update V1
   * @param {string} collectionId
   * @param {Api.UpdateV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public updateV1V1(collectionId: string, request: Api.UpdateV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).updateV1V1(collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Update
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.UpdateV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public updateV2(tenant: string, databaseName: string, collectionId: string, request: Api.UpdateV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).updateV2(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Upsert V1
   * @param {string} collectionId
   * @param {Api.UpsertV1V1Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public upsertV1V1(collectionId: string, request: Api.UpsertV1V1Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).upsertV1V1(collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Upsert
   * @param {string} tenant
   * @param {string} databaseName
   * @param {string} collectionId
   * @param {Api.UpsertV2Request} request
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public upsertV2(tenant: string, databaseName: string, collectionId: string, request: Api.UpsertV2Request, options?: RequestInit) {
    return ApiApiFp(this.configuration).upsertV2(tenant, databaseName, collectionId, request, options)(this.fetch, this.basePath);
  }

  /**
   * @summary Version
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public versionV1(options?: RequestInit) {
    return ApiApiFp(this.configuration).versionV1(options)(this.fetch, this.basePath);
  }

  /**
   * @summary Version
   * @param {RequestInit} [options] Override http request option.
   * @throws {RequiredError}
   */
  public versionV2(options?: RequestInit) {
    return ApiApiFp(this.configuration).versionV2(options)(this.fetch, this.basePath);
  }

}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value: Date | string | undefined): string | undefined {
  if (value instanceof Date) {
    return value.toISOString();
  } else if (typeof value === 'string') {
    return value;
  } else {
    return undefined;
  }
}
