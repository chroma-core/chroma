/* eslint-disable */
// tslint:disable
/**
 * FastAPI
 * 
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError, defaultFetch } from "./runtime";
import { Api } from "./models";

export type FactoryFunction<T> = (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) => T;

/**
 * ApiApi - fetch parameter creator
 * @export
 */
export const ApiApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Add
		 * @param {string} collectionName
		 * @param {Api.AddEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		add(collectionName: string, request: Api.AddEmbedding, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling add.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling add.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}/add`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete
		 * @param {string} collectionName
		 * @param {Api.DeleteEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		aDelete(collectionName: string, request: Api.DeleteEmbedding, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling aDelete.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling aDelete.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}/delete`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get
		 * @param {string} collectionName
		 * @param {Api.GetEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		aGet(collectionName: string, request: Api.GetEmbedding, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling aGet.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling aGet.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}/get`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Count
		 * @param {string} collectionName
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		count(collectionName: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling count.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}/count`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Create Collection
		 * @param {Api.CreateCollection} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createCollection(request: Api.CreateCollection, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createCollection.');
			}
			let localVarPath = `/api/v1/collections`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Create Index
		 * @param {string} collectionName
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createIndex(collectionName: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling createIndex.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}/create_index`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete Collection
		 * @param {string} collectionName
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteCollection(collectionName: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling deleteCollection.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get Collection
		 * @param {string} collectionName
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCollection(collectionName: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling getCollection.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get Nearest Neighbors
		 * @param {string} collectionName
		 * @param {Api.QueryEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNearestNeighbors(collectionName: string, request: Api.QueryEmbedding, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling getNearestNeighbors.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling getNearestNeighbors.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}/query`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Heartbeat
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		heartbeat(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/api/v1/heartbeat`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary List Collections
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listCollections(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/api/v1/collections`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Persist
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		persist(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/api/v1/persist`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Raw Sql
		 * @param {Api.RawSql} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		rawSql(request: Api.RawSql, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling rawSql.');
			}
			let localVarPath = `/api/v1/raw_sql`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Reset
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reset(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/api/v1/reset`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Root
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		root(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/api/v1`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Update
		 * @param {string} collectionName
		 * @param {Api.UpdateEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		update(collectionName: string, request: Api.UpdateEmbedding, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling update.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling update.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}/update`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Update Collection
		 * @param {string} collectionName
		 * @param {Api.UpdateCollection} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateCollection(collectionName: string, request: Api.UpdateCollection, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'collectionName' is not null or undefined
			if (collectionName === null || collectionName === undefined) {
				throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling updateCollection.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateCollection.');
			}
			let localVarPath = `/api/v1/collections/{collection_name}`
				.replace('{collection_name}', encodeURIComponent(String(collectionName)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PUT' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Version
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		version(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/api/v1/version`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Add
		 * @param {string} collectionName
		 * @param {Api.AddEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		add(collectionName: string, request: Api.AddEmbedding, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Add201Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).add(collectionName, request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Delete
		 * @param {string} collectionName
		 * @param {Api.DeleteEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		aDelete(collectionName: string, request: Api.DeleteEmbedding, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ADelete200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).aDelete(collectionName, request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Get
		 * @param {string} collectionName
		 * @param {Api.GetEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		aGet(collectionName: string, request: Api.GetEmbedding, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.AGet200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).aGet(collectionName, request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Count
		 * @param {string} collectionName
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		count(collectionName: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Count200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).count(collectionName, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Create Collection
		 * @param {Api.CreateCollection} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createCollection(request: Api.CreateCollection, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.CreateCollection200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createCollection(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Create Index
		 * @param {string} collectionName
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createIndex(collectionName: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.CreateIndex200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createIndex(collectionName, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Delete Collection
		 * @param {string} collectionName
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteCollection(collectionName: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.DeleteCollection200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteCollection(collectionName, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Get Collection
		 * @param {string} collectionName
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCollection(collectionName: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.GetCollection200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getCollection(collectionName, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Get Nearest Neighbors
		 * @param {string} collectionName
		 * @param {Api.QueryEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNearestNeighbors(collectionName: string, request: Api.QueryEmbedding, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.GetNearestNeighbors200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getNearestNeighbors(collectionName, request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Heartbeat
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		heartbeat(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Heartbeat200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).heartbeat(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary List Collections
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listCollections(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ListCollections200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).listCollections(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Persist
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		persist(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Persist200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).persist(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Raw Sql
		 * @param {Api.RawSql} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		rawSql(request: Api.RawSql, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.RawSql200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).rawSql(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Reset
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reset(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Reset200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).reset(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Root
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		root(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Root200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).root(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Update
		 * @param {string} collectionName
		 * @param {Api.UpdateEmbedding} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		update(collectionName: string, request: Api.UpdateEmbedding, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Update200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).update(collectionName, request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Update Collection
		 * @param {string} collectionName
		 * @param {Api.UpdateCollection} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateCollection(collectionName: string, request: Api.UpdateCollection, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.UpdateCollection200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).updateCollection(collectionName, request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 422) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Version
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		version(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Version200Response> {
			const localVarFetchArgs = ApiApiFetchParamCreator(configuration).version(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory: FactoryFunction<ApiApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ApiApi(configuration, basePath, fetch);
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
	/**
	 * @summary Add
	 * @param {string} collectionName
	 * @param {Api.AddEmbedding} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public add(collectionName: string, request: Api.AddEmbedding, options?: RequestInit) {
		return ApiApiFp(this.configuration).add(collectionName, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete
	 * @param {string} collectionName
	 * @param {Api.DeleteEmbedding} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public aDelete(collectionName: string, request: Api.DeleteEmbedding, options?: RequestInit) {
		return ApiApiFp(this.configuration).aDelete(collectionName, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get
	 * @param {string} collectionName
	 * @param {Api.GetEmbedding} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public aGet(collectionName: string, request: Api.GetEmbedding, options?: RequestInit) {
		return ApiApiFp(this.configuration).aGet(collectionName, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Count
	 * @param {string} collectionName
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public count(collectionName: string, options?: RequestInit) {
		return ApiApiFp(this.configuration).count(collectionName, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Create Collection
	 * @param {Api.CreateCollection} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createCollection(request: Api.CreateCollection, options?: RequestInit) {
		return ApiApiFp(this.configuration).createCollection(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Create Index
	 * @param {string} collectionName
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createIndex(collectionName: string, options?: RequestInit) {
		return ApiApiFp(this.configuration).createIndex(collectionName, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete Collection
	 * @param {string} collectionName
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteCollection(collectionName: string, options?: RequestInit) {
		return ApiApiFp(this.configuration).deleteCollection(collectionName, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get Collection
	 * @param {string} collectionName
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getCollection(collectionName: string, options?: RequestInit) {
		return ApiApiFp(this.configuration).getCollection(collectionName, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get Nearest Neighbors
	 * @param {string} collectionName
	 * @param {Api.QueryEmbedding} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getNearestNeighbors(collectionName: string, request: Api.QueryEmbedding, options?: RequestInit) {
		return ApiApiFp(this.configuration).getNearestNeighbors(collectionName, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Heartbeat
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public heartbeat(options?: RequestInit) {
		return ApiApiFp(this.configuration).heartbeat(options)(this.fetch, this.basePath);
	}

	/**
	 * @summary List Collections
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public listCollections(options?: RequestInit) {
		return ApiApiFp(this.configuration).listCollections(options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Persist
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public persist(options?: RequestInit) {
		return ApiApiFp(this.configuration).persist(options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Raw Sql
	 * @param {Api.RawSql} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public rawSql(request: Api.RawSql, options?: RequestInit) {
		return ApiApiFp(this.configuration).rawSql(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Reset
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public reset(options?: RequestInit) {
		return ApiApiFp(this.configuration).reset(options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Root
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public root(options?: RequestInit) {
		return ApiApiFp(this.configuration).root(options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Update
	 * @param {string} collectionName
	 * @param {Api.UpdateEmbedding} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public update(collectionName: string, request: Api.UpdateEmbedding, options?: RequestInit) {
		return ApiApiFp(this.configuration).update(collectionName, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Update Collection
	 * @param {string} collectionName
	 * @param {Api.UpdateCollection} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public updateCollection(collectionName: string, request: Api.UpdateCollection, options?: RequestInit) {
		return ApiApiFp(this.configuration).updateCollection(collectionName, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Version
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public version(options?: RequestInit) {
		return ApiApiFp(this.configuration).version(options)(this.fetch, this.basePath);
	}

}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value: Date | string | undefined): string | undefined {
	if (value instanceof Date) {
		return value.toISOString();
	} else if (typeof value === 'string') {
		return value;
	} else {
		return undefined;
	}
}
