/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AddEmbedding,
    AddEmbeddingFromJSON,
    AddEmbeddingToJSON,
    CreateCollection,
    CreateCollectionFromJSON,
    CreateCollectionToJSON,
    DeleteEmbedding,
    DeleteEmbeddingFromJSON,
    DeleteEmbeddingToJSON,
    GetEmbedding,
    GetEmbeddingFromJSON,
    GetEmbeddingToJSON,
    HTTPValidationError,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    QueryEmbedding,
    QueryEmbeddingFromJSON,
    QueryEmbeddingToJSON,
    RawSql,
    RawSqlFromJSON,
    RawSqlToJSON,
    UpdateCollection,
    UpdateCollectionFromJSON,
    UpdateCollectionToJSON,
    UpdateEmbedding,
    UpdateEmbeddingFromJSON,
    UpdateEmbeddingToJSON,
} from '../models';

export interface DeleteRequest {
    collectionName: string;
    deleteEmbedding: DeleteEmbedding;
}

export interface AddRequest {
    collectionName: string;
    addEmbedding: AddEmbedding;
}

export interface CountRequest {
    collectionName: string;
}

export interface CreateCollectionRequest {
    createCollection: CreateCollection;
}

export interface CreateIndexRequest {
    collectionName: string;
}

export interface DeleteCollectionRequest {
    collectionName: string;
}

export interface GetRequest {
    collectionName: any;
    getEmbedding: GetEmbedding;
}

export interface GetCollectionRequest {
    collectionName: string;
}

export interface GetNearestNeighborsRequest {
    collectionName: any;
    queryEmbedding: QueryEmbedding;
}

export interface RawSqlRequest {
    rawSql: RawSql;
}

export interface UpdateRequest {
    collectionName: string;
    updateEmbedding: UpdateEmbedding;
}

export interface UpdateCollectionRequest {
    collectionName: any;
    updateCollection: UpdateCollection;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Delete
     */
    async _deleteRaw(requestParameters: DeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling _delete.');
        }

        if (requestParameters.deleteEmbedding === null || requestParameters.deleteEmbedding === undefined) {
            throw new runtime.RequiredError('deleteEmbedding','Required parameter requestParameters.deleteEmbedding was null or undefined when calling _delete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}/delete`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteEmbeddingToJSON(requestParameters.deleteEmbedding),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Delete
     */
    async _delete(requestParameters: DeleteRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this._deleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add
     */
    async addRaw(requestParameters: AddRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling add.');
        }

        if (requestParameters.addEmbedding === null || requestParameters.addEmbedding === undefined) {
            throw new runtime.RequiredError('addEmbedding','Required parameter requestParameters.addEmbedding was null or undefined when calling add.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}/add`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddEmbeddingToJSON(requestParameters.addEmbedding),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Add
     */
    async add(requestParameters: AddRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.addRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Count
     */
    async countRaw(requestParameters: CountRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling count.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}/count`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Count
     */
    async count(requestParameters: CountRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.countRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Collection
     */
    async createCollectionRaw(requestParameters: CreateCollectionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.createCollection === null || requestParameters.createCollection === undefined) {
            throw new runtime.RequiredError('createCollection','Required parameter requestParameters.createCollection was null or undefined when calling createCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/collections`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCollectionToJSON(requestParameters.createCollection),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Create Collection
     */
    async createCollection(requestParameters: CreateCollectionRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.createCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Index
     */
    async createIndexRaw(requestParameters: CreateIndexRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling createIndex.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}/create_index`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Create Index
     */
    async createIndex(requestParameters: CreateIndexRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.createIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Collection
     */
    async deleteCollectionRaw(requestParameters: DeleteCollectionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling deleteCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Delete Collection
     */
    async deleteCollection(requestParameters: DeleteCollectionRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.deleteCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get
     */
    async getRaw(requestParameters: GetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling get.');
        }

        if (requestParameters.getEmbedding === null || requestParameters.getEmbedding === undefined) {
            throw new runtime.RequiredError('getEmbedding','Required parameter requestParameters.getEmbedding was null or undefined when calling get.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}/get`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetEmbeddingToJSON(requestParameters.getEmbedding),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get
     */
    async get(requestParameters: GetRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.getRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Collection
     */
    async getCollectionRaw(requestParameters: GetCollectionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling getCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get Collection
     */
    async getCollection(requestParameters: GetCollectionRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.getCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Nearest Neighbors
     */
    async getNearestNeighborsRaw(requestParameters: GetNearestNeighborsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling getNearestNeighbors.');
        }

        if (requestParameters.queryEmbedding === null || requestParameters.queryEmbedding === undefined) {
            throw new runtime.RequiredError('queryEmbedding','Required parameter requestParameters.queryEmbedding was null or undefined when calling getNearestNeighbors.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}/query`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QueryEmbeddingToJSON(requestParameters.queryEmbedding),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get Nearest Neighbors
     */
    async getNearestNeighbors(requestParameters: GetNearestNeighborsRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.getNearestNeighborsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Collections
     */
    async listCollectionsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/collections`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * List Collections
     */
    async listCollections(initOverrides?: RequestInit): Promise<any> {
        const response = await this.listCollectionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Persist
     */
    async persistRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/persist`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Persist
     */
    async persist(initOverrides?: RequestInit): Promise<any> {
        const response = await this.persistRaw(initOverrides);
        return await response.value();
    }

    /**
     * Raw Sql
     */
    async rawSqlRaw(requestParameters: RawSqlRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.rawSql === null || requestParameters.rawSql === undefined) {
            throw new runtime.RequiredError('rawSql','Required parameter requestParameters.rawSql was null or undefined when calling rawSql.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/raw_sql`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RawSqlToJSON(requestParameters.rawSql),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Raw Sql
     */
    async rawSql(requestParameters: RawSqlRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.rawSqlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reset
     */
    async resetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/reset`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Reset
     */
    async reset(initOverrides?: RequestInit): Promise<any> {
        const response = await this.resetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Root
     */
    async rootRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Root
     */
    async root(initOverrides?: RequestInit): Promise<any> {
        const response = await this.rootRaw(initOverrides);
        return await response.value();
    }

    /**
     * Update
     */
    async updateRaw(requestParameters: UpdateRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling update.');
        }

        if (requestParameters.updateEmbedding === null || requestParameters.updateEmbedding === undefined) {
            throw new runtime.RequiredError('updateEmbedding','Required parameter requestParameters.updateEmbedding was null or undefined when calling update.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}/update`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEmbeddingToJSON(requestParameters.updateEmbedding),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Update
     */
    async update(requestParameters: UpdateRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.updateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Collection
     */
    async updateCollectionRaw(requestParameters: UpdateCollectionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling updateCollection.');
        }

        if (requestParameters.updateCollection === null || requestParameters.updateCollection === undefined) {
            throw new runtime.RequiredError('updateCollection','Required parameter requestParameters.updateCollection was null or undefined when calling updateCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/collections/{collection_name}`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCollectionToJSON(requestParameters.updateCollection),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Update Collection
     */
    async updateCollection(requestParameters: UpdateCollectionRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.updateCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Version
     */
    async versionRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/version`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Version
     */
    async version(initOverrides?: RequestInit): Promise<any> {
        const response = await this.versionRaw(initOverrides);
        return await response.value();
    }

}
