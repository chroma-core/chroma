// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
	context "context"

	dbmodel "github.com/chroma-core/chroma/go/pkg/metastore/db/dbmodel"

	mock "github.com/stretchr/testify/mock"

	model "github.com/chroma-core/chroma/go/pkg/model"

	types "github.com/chroma-core/chroma/go/pkg/types"
)

// ICoordinator is an autogenerated mock type for the ICoordinator type
type ICoordinator struct {
	mock.Mock
}

// CreateCollection provides a mock function with given fields: ctx, createCollection
func (_m *ICoordinator) CreateCollection(ctx context.Context, createCollection *model.CreateCollection) (*model.Collection, error) {
	ret := _m.Called(ctx, createCollection)

	if len(ret) == 0 {
		panic("no return value specified for CreateCollection")
	}

	var r0 *model.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.CreateCollection) (*model.Collection, error)); ok {
		return rf(ctx, createCollection)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.CreateCollection) *model.Collection); ok {
		r0 = rf(ctx, createCollection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.CreateCollection) error); ok {
		r1 = rf(ctx, createCollection)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDatabase provides a mock function with given fields: ctx, createDatabase
func (_m *ICoordinator) CreateDatabase(ctx context.Context, createDatabase *model.CreateDatabase) (*model.Database, error) {
	ret := _m.Called(ctx, createDatabase)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatabase")
	}

	var r0 *model.Database
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.CreateDatabase) (*model.Database, error)); ok {
		return rf(ctx, createDatabase)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.CreateDatabase) *model.Database); ok {
		r0 = rf(ctx, createDatabase)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Database)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.CreateDatabase) error); ok {
		r1 = rf(ctx, createDatabase)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSegment provides a mock function with given fields: ctx, createSegment
func (_m *ICoordinator) CreateSegment(ctx context.Context, createSegment *model.CreateSegment) error {
	ret := _m.Called(ctx, createSegment)

	if len(ret) == 0 {
		panic("no return value specified for CreateSegment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.CreateSegment) error); ok {
		r0 = rf(ctx, createSegment)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTenant provides a mock function with given fields: ctx, createTenant
func (_m *ICoordinator) CreateTenant(ctx context.Context, createTenant *model.CreateTenant) (*model.Tenant, error) {
	ret := _m.Called(ctx, createTenant)

	if len(ret) == 0 {
		panic("no return value specified for CreateTenant")
	}

	var r0 *model.Tenant
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.CreateTenant) (*model.Tenant, error)); ok {
		return rf(ctx, createTenant)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.CreateTenant) *model.Tenant); ok {
		r0 = rf(ctx, createTenant)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Tenant)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.CreateTenant) error); ok {
		r1 = rf(ctx, createTenant)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCollection provides a mock function with given fields: ctx, deleteCollection
func (_m *ICoordinator) DeleteCollection(ctx context.Context, deleteCollection *model.DeleteCollection) error {
	ret := _m.Called(ctx, deleteCollection)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.DeleteCollection) error); ok {
		r0 = rf(ctx, deleteCollection)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSegment provides a mock function with given fields: ctx, segmentID
func (_m *ICoordinator) DeleteSegment(ctx context.Context, segmentID types.UniqueID) error {
	ret := _m.Called(ctx, segmentID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSegment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.UniqueID) error); ok {
		r0 = rf(ctx, segmentID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FlushCollectionCompaction provides a mock function with given fields: ctx, flushCollectionCompaction
func (_m *ICoordinator) FlushCollectionCompaction(ctx context.Context, flushCollectionCompaction *model.FlushCollectionCompaction) (*model.FlushCollectionInfo, error) {
	ret := _m.Called(ctx, flushCollectionCompaction)

	if len(ret) == 0 {
		panic("no return value specified for FlushCollectionCompaction")
	}

	var r0 *model.FlushCollectionInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.FlushCollectionCompaction) (*model.FlushCollectionInfo, error)); ok {
		return rf(ctx, flushCollectionCompaction)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.FlushCollectionCompaction) *model.FlushCollectionInfo); ok {
		r0 = rf(ctx, flushCollectionCompaction)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.FlushCollectionInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.FlushCollectionCompaction) error); ok {
		r1 = rf(ctx, flushCollectionCompaction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollections provides a mock function with given fields: ctx, collectionID, collectionName, tenantID, dataName, limit, offset
func (_m *ICoordinator) GetCollections(ctx context.Context, collectionID types.UniqueID, collectionName *string, tenantID string, dataName string, limit *int32, offset *int32) ([]*model.Collection, error) {
	ret := _m.Called(ctx, collectionID, collectionName, tenantID, dataName, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetCollections")
	}

	var r0 []*model.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.UniqueID, *string, string, string, *int32, *int32) ([]*model.Collection, error)); ok {
		return rf(ctx, collectionID, collectionName, tenantID, dataName, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.UniqueID, *string, string, string, *int32, *int32) []*model.Collection); ok {
		r0 = rf(ctx, collectionID, collectionName, tenantID, dataName, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.UniqueID, *string, string, string, *int32, *int32) error); ok {
		r1 = rf(ctx, collectionID, collectionName, tenantID, dataName, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatabase provides a mock function with given fields: ctx, getDatabase
func (_m *ICoordinator) GetDatabase(ctx context.Context, getDatabase *model.GetDatabase) (*model.Database, error) {
	ret := _m.Called(ctx, getDatabase)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabase")
	}

	var r0 *model.Database
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.GetDatabase) (*model.Database, error)); ok {
		return rf(ctx, getDatabase)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.GetDatabase) *model.Database); ok {
		r0 = rf(ctx, getDatabase)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Database)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.GetDatabase) error); ok {
		r1 = rf(ctx, getDatabase)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSegments provides a mock function with given fields: ctx, segmentID, segmentType, scope, collectionID
func (_m *ICoordinator) GetSegments(ctx context.Context, segmentID types.UniqueID, segmentType *string, scope *string, collectionID types.UniqueID) ([]*model.Segment, error) {
	ret := _m.Called(ctx, segmentID, segmentType, scope, collectionID)

	if len(ret) == 0 {
		panic("no return value specified for GetSegments")
	}

	var r0 []*model.Segment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.UniqueID, *string, *string, types.UniqueID) ([]*model.Segment, error)); ok {
		return rf(ctx, segmentID, segmentType, scope, collectionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.UniqueID, *string, *string, types.UniqueID) []*model.Segment); ok {
		r0 = rf(ctx, segmentID, segmentType, scope, collectionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Segment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.UniqueID, *string, *string, types.UniqueID) error); ok {
		r1 = rf(ctx, segmentID, segmentType, scope, collectionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTenant provides a mock function with given fields: ctx, getTenant
func (_m *ICoordinator) GetTenant(ctx context.Context, getTenant *model.GetTenant) (*model.Tenant, error) {
	ret := _m.Called(ctx, getTenant)

	if len(ret) == 0 {
		panic("no return value specified for GetTenant")
	}

	var r0 *model.Tenant
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.GetTenant) (*model.Tenant, error)); ok {
		return rf(ctx, getTenant)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.GetTenant) *model.Tenant); ok {
		r0 = rf(ctx, getTenant)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Tenant)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.GetTenant) error); ok {
		r1 = rf(ctx, getTenant)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTenantsLastCompactionTime provides a mock function with given fields: ctx, tenantIDs
func (_m *ICoordinator) GetTenantsLastCompactionTime(ctx context.Context, tenantIDs []string) ([]*dbmodel.Tenant, error) {
	ret := _m.Called(ctx, tenantIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetTenantsLastCompactionTime")
	}

	var r0 []*dbmodel.Tenant
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*dbmodel.Tenant, error)); ok {
		return rf(ctx, tenantIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*dbmodel.Tenant); ok {
		r0 = rf(ctx, tenantIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dbmodel.Tenant)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, tenantIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetState provides a mock function with given fields: ctx
func (_m *ICoordinator) ResetState(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ResetState")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetTenantLastCompactionTime provides a mock function with given fields: ctx, tenantID, lastCompactionTime
func (_m *ICoordinator) SetTenantLastCompactionTime(ctx context.Context, tenantID string, lastCompactionTime int64) error {
	ret := _m.Called(ctx, tenantID, lastCompactionTime)

	if len(ret) == 0 {
		panic("no return value specified for SetTenantLastCompactionTime")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) error); ok {
		r0 = rf(ctx, tenantID, lastCompactionTime)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Start provides a mock function with given fields:
func (_m *ICoordinator) Start() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stop provides a mock function with given fields:
func (_m *ICoordinator) Stop() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCollection provides a mock function with given fields: ctx, updateCollection
func (_m *ICoordinator) UpdateCollection(ctx context.Context, updateCollection *model.UpdateCollection) (*model.Collection, error) {
	ret := _m.Called(ctx, updateCollection)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCollection")
	}

	var r0 *model.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.UpdateCollection) (*model.Collection, error)); ok {
		return rf(ctx, updateCollection)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.UpdateCollection) *model.Collection); ok {
		r0 = rf(ctx, updateCollection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.UpdateCollection) error); ok {
		r1 = rf(ctx, updateCollection)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSegment provides a mock function with given fields: ctx, updateSegment
func (_m *ICoordinator) UpdateSegment(ctx context.Context, updateSegment *model.UpdateSegment) (*model.Segment, error) {
	ret := _m.Called(ctx, updateSegment)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSegment")
	}

	var r0 *model.Segment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.UpdateSegment) (*model.Segment, error)); ok {
		return rf(ctx, updateSegment)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.UpdateSegment) *model.Segment); ok {
		r0 = rf(ctx, updateSegment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Segment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.UpdateSegment) error); ok {
		r1 = rf(ctx, updateSegment)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewICoordinator creates a new instance of ICoordinator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewICoordinator(t interface {
	mock.TestingT
	Cleanup(func())
}) *ICoordinator {
	mock := &ICoordinator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
