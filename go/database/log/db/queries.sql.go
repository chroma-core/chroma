// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package log

import (
	"context"
)

const getAllCollectionsToCompact = `-- name: GetAllCollectionsToCompact :many
with summary as (
    select r.collection_id, r.offset, r.timestamp, row_number() over(partition by r.collection_id order by r.offset) as rank
    from record_log r, collection c
    where r.collection_id = c.id
    and r.offset > c.record_compaction_offset_position
)
select collection_id, "offset", timestamp, rank from summary
where rank=1
order by timestamp
`

type GetAllCollectionsToCompactRow struct {
	CollectionID string
	Offset       int64
	Timestamp    int64
	Rank         int64
}

func (q *Queries) GetAllCollectionsToCompact(ctx context.Context) ([]GetAllCollectionsToCompactRow, error) {
	rows, err := q.db.Query(ctx, getAllCollectionsToCompact)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCollectionsToCompactRow
	for rows.Next() {
		var i GetAllCollectionsToCompactRow
		if err := rows.Scan(
			&i.CollectionID,
			&i.Offset,
			&i.Timestamp,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionForUpdate = `-- name: GetCollectionForUpdate :one
SELECT id, record_compaction_offset_position, record_enumeration_offset_position
FROM collection
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetCollectionForUpdate(ctx context.Context, id string) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollectionForUpdate, id)
	var i Collection
	err := row.Scan(&i.ID, &i.RecordCompactionOffsetPosition, &i.RecordEnumerationOffsetPosition)
	return i, err
}

const getRecordsForCollection = `-- name: GetRecordsForCollection :many
SELECT "offset", collection_id, timestamp, record FROM record_log r WHERE r.collection_id = $1 AND r.offset >= $2 and r.timestamp <= $4  ORDER BY r.offset ASC limit $3
`

type GetRecordsForCollectionParams struct {
	CollectionID string
	Offset       int64
	Limit        int32
	Timestamp    int64
}

func (q *Queries) GetRecordsForCollection(ctx context.Context, arg GetRecordsForCollectionParams) ([]RecordLog, error) {
	rows, err := q.db.Query(ctx, getRecordsForCollection,
		arg.CollectionID,
		arg.Offset,
		arg.Limit,
		arg.Timestamp,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecordLog
	for rows.Next() {
		var i RecordLog
		if err := rows.Scan(
			&i.Offset,
			&i.CollectionID,
			&i.Timestamp,
			&i.Record,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCollection = `-- name: InsertCollection :one
INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning id, record_compaction_offset_position, record_enumeration_offset_position
`

type InsertCollectionParams struct {
	ID                              string
	RecordEnumerationOffsetPosition int64
	RecordCompactionOffsetPosition  int64
}

func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, insertCollection, arg.ID, arg.RecordEnumerationOffsetPosition, arg.RecordCompactionOffsetPosition)
	var i Collection
	err := row.Scan(&i.ID, &i.RecordCompactionOffsetPosition, &i.RecordEnumerationOffsetPosition)
	return i, err
}

type InsertRecordParams struct {
	CollectionID string
	Offset       int64
	Record       []byte
	Timestamp    int64
}

const updateCollectionCompactionOffsetPosition = `-- name: UpdateCollectionCompactionOffsetPosition :exec
UPDATE collection set record_compaction_offset_position = $2 where id = $1
`

type UpdateCollectionCompactionOffsetPositionParams struct {
	ID                             string
	RecordCompactionOffsetPosition int64
}

func (q *Queries) UpdateCollectionCompactionOffsetPosition(ctx context.Context, arg UpdateCollectionCompactionOffsetPositionParams) error {
	_, err := q.db.Exec(ctx, updateCollectionCompactionOffsetPosition, arg.ID, arg.RecordCompactionOffsetPosition)
	return err
}

const updateCollectionEnumerationOffsetPosition = `-- name: UpdateCollectionEnumerationOffsetPosition :exec
UPDATE collection set record_enumeration_offset_position = $2 where id = $1
`

type UpdateCollectionEnumerationOffsetPositionParams struct {
	ID                              string
	RecordEnumerationOffsetPosition int64
}

func (q *Queries) UpdateCollectionEnumerationOffsetPosition(ctx context.Context, arg UpdateCollectionEnumerationOffsetPositionParams) error {
	_, err := q.db.Exec(ctx, updateCollectionEnumerationOffsetPosition, arg.ID, arg.RecordEnumerationOffsetPosition)
	return err
}
