---
title: "Metadata Filtering"
description: "Learn how to filter query results by metadata in Chroma collections."
---

The `where` argument in `get` and `query` is used to filter records by their metadata. For example, in this `query` operation, Chroma will only query records that have the `page` metadata field with the value `10`:

<CodeGroup>
```python Python
collection.query(
    query_texts=["first query", "second query"],
    where={"page": 10}
)
```

```typescript TypeScript
await collection.query({
  queryTexts: ["first query", "second query"],
  where: { page: 10 },
});
```

```rust Rust
let where_clause = Where::Metadata(MetadataExpression {
    key: "page".to_string(),
    comparison: MetadataComparison::Primitive(
        PrimitiveOperator::Equal,
        MetadataValue::Int(10),
    ),
});

let results = collection
    .query(vec![vec![0.1, 0.2, 0.3]], Some(10), Some(where_clause), None, None)
    .await?;
```
</CodeGroup>

In order to filter on metadata, you must supply a `where` filter dictionary to the query. The dictionary must have the following structure:

<CodeGroup>
```python Python
{
    "metadata_field": {
        <Operator>: <Value>
    }
}
```

```typescript TypeScript
{
    metadata_field: {
        <Operator>: <Value>
    }
}
```

```rust Rust
let where_clause = Where::Metadata(MetadataExpression {
    key: "metadata_field".to_string(),
    comparison: MetadataComparison::Primitive(
        PrimitiveOperator::Equal,
        MetadataValue::Str("value".to_string()),
    ),
});
```
</CodeGroup>

Using the `$eq` operator is equivalent to using the metadata field directly in your `where` filter.

<CodeGroup>
```python Python
{
    "metadata_field": "search_string"
}

# is equivalent to

{
    "metadata_field": {
        "$eq": "search_string"
    }
}
```

```typescript TypeScript
{
    metadata_field: "search_string"
}

// is equivalent to

{
    metadata_field: {
        "$eq":"search_string"
    }
}
```

```rust Rust
let direct = Where::Metadata(MetadataExpression {
    key: "metadata_field".to_string(),
    comparison: MetadataComparison::Primitive(
        PrimitiveOperator::Equal,
        MetadataValue::Str("search_string".to_string()),
    ),
});
```
</CodeGroup>

For example, here we query all records whose `page` metadata field is greater than 10:

<CodeGroup>
```python Python
collection.query(
    query_texts=["first query", "second query"],
    where={"page": { "$gt": 10 }}
)
```

```typescript TypeScript
await collection.query({
  queryTexts: ["first query", "second query"],
  where: { page: { $gt: 10 } },
});
```

```rust Rust
let where_clause = Where::Metadata(MetadataExpression {
    key: "page".to_string(),
    comparison: MetadataComparison::Primitive(
        PrimitiveOperator::GreaterThan,
        MetadataValue::Int(10),
    ),
});

let results = collection
    .query(vec![vec![0.1, 0.2, 0.3]], Some(10), Some(where_clause), None, None)
    .await?;
```
</CodeGroup>

## Using Logical Operators

You can also use the logical operators `$and` and `$or` to combine multiple filters.

An `$and` operator will return results that match all the filters in the list.

<CodeGroup>
```python Python
{
    "$and": [
        {
            "metadata_field": {
                <Operator>: <Value>
            }
        },
        {
            "metadata_field": {
                <Operator>: <Value>
            }
        }
    ]
}
```

```typescript TypeScript
{
    "$and": [
        {
            metadata_field: { <Operator>: <Value> }
        },
        {
            metadata_field: { <Operator>: <Value> }
        }
    ]
}
```

```rust Rust
let filter = Key::field("metadata_field").gte(5) & Key::field("metadata_field").lte(10);
```
</CodeGroup>

For example, here we query all records whose `page` metadata field is between 5 and 10:

<CodeGroup>
```python Python
collection.query(
    query_texts=["first query", "second query"],
    where={
        "$and": [
            {"page": {"$gte": 5 }},
            {"page": {"$lte": 10 }},
        ]
    }
)
```

```typescript TypeScript
await collection.query({
  queryTexts: ["first query", "second query"],
  where: {
    $and: [{ page: { $gte: 5 } }, { page: { $lte: 10 } }],
  },
});
```

```rust Rust
let search = SearchPayload::default()
    .r#where(Key::field("page").gte(5) & Key::field("page").lte(10))
    .rank(RankExpr::Knn {
        query: QueryVector::Dense(vec![0.1, 0.2, 0.3]),
        key: Key::Embedding,
        limit: 10,
        default: None,
        return_rank: false,
    })
    .limit(Some(10), 0);

let results = collection.search(vec![search]).await?;
```
</CodeGroup>

An `$or` operator will return results that match any of the filters in the list.

<CodeGroup>
```python Python
{
    "$or": [
        {
            "metadata_field": {
                <Operator>: <Value>
            }
        },
        {
            "metadata_field": {
                <Operator>: <Value>
            }
        }
    ]
}
```

```typescript TypeScript
{
    "$or": [
        {
            metadata_field: { <Operator>: <Value> }
        },
        {
            metadata_field: { <Operator>: <Value> }
        }
    ]
}
```

```rust Rust
let filter = Key::field("metadata_field").eq("value1")
    | Key::field("metadata_field").eq("value2");
```
</CodeGroup>

For example, here we get all records whose `color` metadata field is `red` or `blue`:

<CodeGroup>
```python Python
collection.get(
    where={
        "or": [
            {"color": "red"},
            {"color": "blue"},
        ]
    }
)
```

```typescript TypeScript
await collection.get({
  where: {
    or: [{ color: "red" }, { color: "blue" }],
  },
});
```

```rust Rust
let search = SearchPayload::default()
    .r#where(Key::field("color").eq("red") | Key::field("color").eq("blue"));

let results = collection.search(vec![search]).await?;
```
</CodeGroup>

## Using Inclusion Operators

The following inclusion operators are supported:

- `$in` - a value is in predefined list (string, int, float, bool)
- `$nin` - a value is not in predefined list (string, int, float, bool)

An `$in` operator will return results where the metadata attribute is part of a provided list:

<CodeGroup>
```python Python
{
  "metadata_field": {
    "$in": ["value1", "value2", "value3"]
  }
}
```

```typescript TypeScript
{
    metadata_field: {
        "$in": ["value1", "value2", "value3"]
    }
}
```

```rust Rust
let filter = Key::field("metadata_field").is_in(["value1", "value2", "value3"]);
```
</CodeGroup>

An `$nin` operator will return results where the metadata attribute is not part of a provided list (or the attribute's key is not present):

<CodeGroup>
```python Python
{
  "metadata_field": {
    "$nin": ["value1", "value2", "value3"]
  }
}
```

```typescript TypeScript
{
    metadata_field: {
        "$nin": ["value1", "value2", "value3"]
    }
}
```

```rust Rust
let filter = Key::field("metadata_field").not_in(["value1", "value2", "value3"]);
```
</CodeGroup>

For example, here we get all records whose `author` metadata field is in a list of possible values:

<CodeGroup>
```python Python
collection.get(
    where={
       "author": {"$in": ["Rowling", "Fitzgerald", "Herbert"]}
    }
)
```

```typescript TypeScript
await collection.get({
  where: {
    author: { $in: ["Rowling", "Fitzgerald", "Herbert"] },
  },
});
```

```rust Rust
let search = SearchPayload::default()
    .r#where(Key::field("author").is_in(["Rowling", "Fitzgerald", "Herbert"]));

let results = collection.search(vec![search]).await?;
```
</CodeGroup>

## Combining with Document Search

`.get` and `.query` can handle metadata filtering combined with [document search](./full-text-search):

<CodeGroup>
```python Python
collection.query(
    query_texts=["doc10", "thus spake zarathustra", ...],
    n_results=10,
    where={"metadata_field": "is_equal_to_this"},
    where_document={"$contains":"search_string"}
)
```

```typescript TypeScript
await collection.query({
    queryTexts: ["doc10", "thus spake zarathustra", ...],
    nResults: 10,
    where: { metadata_field: "is_equal_to_this" },
    whereDocument: { "$contains": "search_string" }
})
```

```rust Rust
let search = SearchPayload::default()
    .r#where(
        Key::field("metadata_field").eq("is_equal_to_this")
            & Key::Document.contains("search_string"),
    )
    .rank(RankExpr::Knn {
        query: QueryVector::Dense(vec![0.1, 0.2, 0.3]),
        key: Key::Embedding,
        limit: 10,
        default: None,
        return_rank: false,
    })
    .limit(Some(10), 0);

let results = collection.search(vec![search]).await?;
```
</CodeGroup>
