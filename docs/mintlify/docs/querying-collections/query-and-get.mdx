---
title: "Query and Get"
description: "Learn how to query and retrieve data from Chroma collections."
---
import { Callout } from '/snippets/callout.mdx';

<Callout title="New Search API Available">
Dense vector search, hybrid search, and more are available in the new powerful [Search API](/cloud/search-api/overview) for Chroma Cloud databases.
</Callout>

The Query API enables nearest-neighbor similarity search over dense embeddings.
Use the Get API when you want to retrieve records without similarity ranking.

<Tabs>
<Tab title="Python" icon="python">

## Query

You can query a collection to run a similarity search using `.query`:

```python
collection.query(
    query_texts=["thus spake zarathustra", "the oracle speaks"]
)
```

Chroma will use the collection's [embedding function](../embeddings/embedding-functions) to embed your text queries, and use the output to run a vector similarity search against your collection.

Instead of providing `query_texts`, you can provide `query_embeddings` directly. You will be required to do so if your collection does not have an embedding function attached to it. The dimension of your query embedding must match the dimension of the embeddings in your collection.

Python also supports `query_images` and `query_uris` as query inputs.

```python
collection.query(
    query_embeddings=[[11.1, 12.1, 13.1], [1.1, 2.3, 3.2]]
)
```

By default, Chroma will return 10 results per input query. You can modify this number using the `n_results` argument:

```python
collection.query(
    query_embeddings=[[11.1, 12.1, 13.1], [1.1, 2.3, 3.2]],
    n_results=100
)
```

The `ids` argument lets you constrain the search only to records with the IDs from the provided list:

```python
collection.query(
    query_embeddings=[[11.1, 12.1, 13.1], [1.1, 2.3, 3.2]],
    n_results=100,
    ids=["id1", "id2"]
)
```

Both `query` and `get` support `where` for [metadata filtering](./metadata-filtering) and `where_document` for [full-text search and regex](./full-text-search):

```python
collection.query(
    query_embeddings=[[11.1, 12.1, 13.1], [1.1, 2.3, 3.2]],
    n_results=100,
    where={"page": 10}, # query records with metadata field 'page' equal to 10
    where_document={"$contains": "search string"} # query records with the search string in the records' document
)
```

## Get

Use `.get` to retrieve records by ID and/or filters without similarity ranking:

```python
collection.get(ids=["id1", "id2"]) # by IDs

collection.get(limit=100, offset=0) # with pagination
```

</Tab>

<Tab title="TypeScript" icon="js">

## Query

You can query a collection to run a similarity search using `.query`:

```typescript
await collection.query({
  queryTexts: ["thus spake zarathustra", "the oracle speaks"],
});
```

Chroma will use the collection's [embedding function](../embeddings/embedding-functions) to embed your text queries, and use the output to run a vector similarity search against your collection.

Instead of providing `queryTexts`, you can provide `queryEmbeddings` directly. You will be required to do so if your collection does not have an embedding function attached to it. The dimension of your query embedding must match the dimension of the embeddings in your collection.


```typescript
await collection.query({
  queryEmbeddings: [
    [11.1, 12.1, 13.1],
    [1.1, 2.3, 3.2],
  ],
});
```

By default, Chroma will return 10 results per input query. You can modify this number using the `nResults` argument:

```typescript
await collection.query({
  queryEmbeddings: [
    [11.1, 12.1, 13.1],
    [1.1, 2.3, 3.2],
  ],
  nResults: 100,
});
```

The `ids` argument lets you constrain the search only to records with the IDs from the provided list:

```typescript
await collection.query({
  queryEmbeddings: [
    [11.1, 12.1, 13.1],
    [1.1, 2.3, 3.2],
  ],
  nResults: 100,
  ids: ["id1", "id2"],
});
```

Both `query` and `get` support `where` for [metadata filtering](./metadata-filtering) and `whereDocument` for [full-text search and regex](./full-text-search):

```typescript
await collection.query({
  queryEmbeddings: [
    [11.1, 12.1, 13.1],
    [1.1, 2.3, 3.2],
  ],
  nResults: 5,
  where: { page: 10 }, // metadata field 'page' equal to 10
  whereDocument: { $contains: "search string" }, // documents containing "search string"
});
```

## Get

Use `.get` to retrieve records by ID and/or filters without similarity ranking:

```typescript
await collection.get({ ids: ["id1", "id2"] }); // By IDs

await collection.get({ limit: 100, offset: 0 }); // With pagination
```

## Type inference

You can also pass type arguments to `.get` and `.query` for the shape of your metadata. This gives you type inference for your metadata objects:

```typescript
const results = await collection.get<{page: number; title: string}>({
  ids: ["id1", "id2"],
});

const rows = results.rows();
rows.forEach((row) => {
  console.log(row.id, row.metadata?.page);
});
```

</Tab>

<Tab title="Rust" icon="rust">

## Query

You can query a collection to run a similarity search using `.query`:

```rust
use chroma_types::IncludeList;

// pub async fn query(
//    &self,
//    query_embeddings: Vec<Vec<f32>>,
//    n_results: Option<u32>,
//    where: Option<Where>,
//    ids: Option<Vec<String>>,
//    include: Option<IncludeList>,
// ) -> Result<QueryResponse, ChromaHttpClientError>

let results = collection
    .query(
        vec![vec![11.1, 12.1, 13.1], vec![1.1, 2.3, 3.2]],
        None,
        None,
        None,
        None,
    )
    .await?;
```

Embeddings must be provided directly to the Rust client.

By default, Chroma returns 10 results per input query. You can modify this number using `n_results`:

```rust
let results = collection
    .query(
        vec![vec![11.1, 12.1, 13.1], vec![1.1, 2.3, 3.2]],
        Some(100), // n_results
        None,
        None,
        None,
    )
    .await?;
```

The `ids` argument lets you constrain the search only to records with the IDs from the provided list:

```rust
let results = collection
    .query(
        vec![vec![11.1, 12.1, 13.1], vec![1.1, 2.3, 3.2]],
        Some(5),
        None,
        Some(vec!["id1".to_string(), "id2".to_string()]), // ids
        None,
    )
    .await?;
```

## Get

Use `.get` to retrieve records by ID and/or filters without similarity ranking:

```rust
let response = collection
    .get(
        Some(vec!["id1".to_string(), "id2".to_string()]),
        None,
        Some(10),
        Some(0),
        Some(IncludeList::default_get()),
    )
    .await?;
```

</Tab>

<Tab title="Go" icon="golang">

You can query a Chroma collection to run a similarity search using the `.Query` method:

```go Go
results, err := collection.Query(ctx,
    chroma.WithQueryTexts("thus spake zarathustra", "the oracle speaks"),
)
```

Chroma will use the collection's [embedding function](../embeddings/embedding-functions) to embed your text queries, and use the output to run a vector similarity search against your collection.

Instead of providing `query_texts`, you can provide query embeddings directly:

```go Go
results, err := collection.Query(ctx,
    chroma.WithQueryEmbeddings(
        []float32{11.1, 12.1, 13.1},
        []float32{1.1, 2.3, 3.2},
    ),
)
```

By default, Chroma will return 10 results per input query. You can modify this using `WithNResults`:

```go Go
results, err := collection.Query(ctx,
    chroma.WithQueryTexts("search query"),
    chroma.WithNResults(5),
)
```

The `WithIDs` option lets you constrain the search only to records with the IDs from the provided list:

```go Go
results, err := collection.Query(ctx,
    chroma.WithQueryTexts("search query"),
    chroma.WithNResults(5),
    chroma.WithIDs("id1", "id2"),
)
```

You can also retrieve records from a collection by using the `.Get` method:

```go Go
results, err := collection.Get(ctx, chroma.WithIDs("id1", "id2"))
```

Both `Query` and `Get` have the `where` argument for [metadata filtering](./metadata-filtering) and `where_document` for [full-text search and regex](./full-text-search):

```go Go
results, err := collection.Query(ctx,
    chroma.WithQueryTexts("search query"),
    chroma.WithNResults(5),
    chroma.WithWhere(chroma.EqInt("page", 10)),
    chroma.WithWhereDocument(chroma.Contains("search string")),
)
```

## Results Shape

Chroma returns `.Query` and `.Get` results in columnar form. Query results are grouped by input query.

```go Go
// QueryResult methods:
results.GetIDsGroups()         // [][]string - IDs grouped by query
results.GetDocumentsGroups()   // [][]string - Documents grouped by query
results.GetMetadatasGroups()   // Metadata grouped by query
results.GetDistancesGroups()   // [][]float32 - Distances grouped by query

// GetResult methods:
results.GetIDs()        // []string - List of IDs
results.GetDocuments()  // []string - List of documents
results.GetMetadatas()  // List of metadata
```

`.Query` results are indexed by each of your input queries. For example, `results.GetIDsGroups()[0]` contains the list of record IDs for the results of the first input query.

Use `.Rows()` for easy iteration over results:

```go Go
for _, row := range results.Rows() {
    fmt.Printf("ID: %s, Document: %s, Score: %f\n", row.ID, row.Document, row.Score)
}
```

## Choosing Which Data is Returned

By default, `.Query` and `.Get` always return the `documents` and `metadatas`. You can use the `include` options to modify what gets returned:

```go Go
// Default query - returns ids, documents, metadatas
results, _ := collection.Query(ctx, chroma.WithQueryTexts("my query"))

// Get with only documents
results, _ := collection.Get(ctx, chroma.WithInclude(chroma.IncludeDocuments))

// Query with specific includes
results, _ := collection.Query(ctx,
    chroma.WithQueryTexts("my query"),
    chroma.WithInclude(chroma.IncludeDocuments, chroma.IncludeMetadatas, chroma.IncludeEmbeddings),
)
```

</Tab>
</Tabs>

## Results Shape

Chroma returns `.query` and `.get` results in **column-major** form (arrays per field). `.query` results are grouped per input query; `.get` results are a flat list of records.

<CodeGroup>
```python Python
class QueryResult(TypedDict):
    ids: List[IDs]
    embeddings: Optional[List[Embeddings]]
    documents: Optional[List[List[Document]]]
    uris: Optional[List[List[URI]]]
    metadatas: Optional[List[List[Metadata]]]
    distances: Optional[List[List[float]]]
    included: Include

class GetResult(TypedDict):
    ids: List[ID]
    embeddings: Optional[Embeddings]
    documents: Optional[List[Document]]
    uris: Optional[URIs]
    metadatas: Optional[List[Metadata]]
    included: Include
```

```typescript TypeScript
class QueryResult {
  public readonly ids: string[][];
  public readonly distances: (number | null)[][];
  public readonly documents: (string | null)[][];
  public readonly embeddings: (number[] | null)[][];
  public readonly metadatas: (Record<string, string | number | boolean> | null)[][];
  public readonly uris: (string | null)[][];
  public readonly include: Include[];
}

class GetResult {
  public readonly ids: string[];
  public readonly documents: (string | null)[];
  public readonly embeddings: number[][];
  public readonly metadatas: (Record<string, string | number | boolean> | null)[];
  public readonly uris: (string | null)[];
  public readonly include: Include[];
}
```

```rust Rust
pub struct QueryResponse {
    pub ids: Vec<Vec<String>>,
    pub embeddings: Option<Vec<Vec<Option<Vec<f32>>>>>,
    pub documents: Option<Vec<Vec<Option<String>>>>,
    pub uris: Option<Vec<Vec<Option<String>>>>,
    pub metadatas: Option<Vec<Vec<Option<HashMap<String, MetadataValue>>>>>,
    pub distances: Option<Vec<Vec<Option<f32>>>>,
    pub include: Vec<Include>,
}

pub struct GetResponse {
    pub ids: Vec<String>,
    pub embeddings: Option<Vec<Vec<f32>>>,
    pub documents: Option<Vec<Option<String>>>,
    pub uris: Option<Vec<Option<String>>>,
    pub metadatas: Option<Vec<Option<HashMap<String, MetadataValue>>>>,
    pub include: Vec<Include>,
}
```
</CodeGroup>

In the results from the Get operation, corresponding elements in each array belong
to the same document.

<CodeGroup>
```python Python
result = collection.get(include=["documents", "metadatas"])
for id, document, metadata in zip(result["ids"], result["documents"], result["metadatas"]):
    print(id, document, metadata)
```

```typescript TypeScript
const result = await collection.get();

const first_document = {
    id: result["ids"][0],
    document: result["documents"][0],
    metadatas: result["metadatas"][0]
}

// Use the .rows() function for easy iteration
for (const row of result.rows()) {
  console.log(row.id, row.document, row.metadata);
}
```

```rust Rust
let result = collection.get(None, None, None, None, None).await?;
if let (Some(documents), Some(metadatas)) = (&result.documents, &result.metadatas) {
    for i in 0..result.ids.len() {
        let id = &result.ids[i];
        let document = &documents[i];
        let metadata = &metadatas[i];
        println!("{id:?} {document:?} {metadata:?}");
    }
}
```
</CodeGroup>

Query is a batch API and returns results grouped per input. A common pattern is to iterate over each query's “batch” of results, then iterate within that batch.

<CodeGroup>
```python Python
result = collection.query(query_texts=["first query", "second query"])
for ids, documents, metadatas in zip(result["ids"], result["documents"], result["metadatas"]):
    for id, document, metadata in zip(ids, documents, metadatas):
        print(id, document, metadata)
```

```typescript TypeScript
const result = await collection.query({ queryTexts: ["first query", "second query"] });
for (const batch of result.rows()) {
  for (const row of batch) {
    console.log(row.id, row.document, row.metadata, row.distance);
  }
}
```

```rust Rust
let result = collection
    .query(vec![vec![0.1, 0.2, 0.3]], None, None, None, None)
    .await?;

if let (Some(doc_batches), Some(meta_batches)) = (&result.documents, &result.metadatas) {
    for batch_i in 0..result.ids.len() {
        let ids = &result.ids[batch_i];
        let documents = &doc_batches[batch_i];
        let metadatas = &meta_batches[batch_i];
        for j in 0..ids.len() {
            let id = &ids[j];
            let document = &documents[j];
            let metadata = &metadatas[j];
            println!("{id:?} {document:?} {metadata:?}");
        }
    }
}
```
</CodeGroup>

## Choosing Which Data is Returned

By default, Query returns `documents`, `metadatas`, and `distances`, and Get returns `documents` and `metadatas`.

Use `include` to control what comes back. `ids` are always returned.

<CodeGroup>
```python Python
collection.query(
    query_texts=["my query"],
    include=["documents", "metadatas", "embeddings"],
)

collection.get(include=["documents"])
```

```typescript TypeScript
await collection.query({
  queryTexts: ["my query"],
  include: ["documents", "metadatas", "embeddings"],
});

await collection.get({ include: ["documents"] });
```

```rust Rust
use chroma_types::{Include, IncludeList};

let include = IncludeList(vec![Include::Document, Include::Metadata]);

let results = collection
    .query(vec![vec![0.1, 0.2, 0.3]], Some(5), None, None, Some(include))
    .await?;
```
</CodeGroup>
